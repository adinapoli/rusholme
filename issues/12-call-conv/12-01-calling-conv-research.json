{
    "title": "Research: Calling convention for compiled Haskell (eval/apply vs push/enter vs CPS)",
    "epic": 12,
    "milestone": "M1: Hello World",
    "labels": [
        "priority:high",
        "component:runtime",
        "type:research"
    ],
    "depends_on": [],
    "body": "Research and recommend a calling convention for Rusholme's compiled Haskell functions.\n\n**Options to evaluate:**\n1. **Eval/apply** (GHC's current approach) \u2014 caller evaluates arguments, callee receives evaluated values. Simpler for backends. See Marlow & Peyton Jones 'Making a Fast Curry' (2004).\n2. **Push/enter** \u2014 arguments pushed onto stack, callee pops what it needs. Better for partial application but harder for LLVM.\n3. **CPS (Continuation-Passing Style)** \u2014 every function takes an explicit continuation. Natural for lazy evaluation but can blow up code size.\n4. **Direct style with thunks** \u2014 standard C-like calls with thunk objects for laziness. Simplest for LLVM backend.\n\n**Evaluation criteria:**\n- Compatibility with GRIN's explicit thunk representation\n- LLVM backend friendliness (LLVM has opinions about calling conventions)\n- Handling of partial application and over-application\n- Implementation complexity\n- Performance implications\n\n**Deliverable:** Written recommendation in `docs/decisions/` with chosen approach.\n\n**Key references:**\n- Marlow & Peyton Jones, 'Making a Fast Curry: Push/Enter vs. Eval/Apply for Higher-Order Languages', JFP 2006\n- GHC calling convention: https://gitlab.haskell.org/ghc/ghc/-/wikis/commentary/rts/haskell-execution/calling-convention\n- GRIN calling model: Hruska et al. 2020 (see docs/references/grin-overview.md)",
    "github_issue": 66,
    "depends_on_github": [],
    "state": "open"
}