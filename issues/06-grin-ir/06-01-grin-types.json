{
    "title": "Define GRIN IR types (Modern GRIN dialect)",
    "epic": 6,
    "milestone": "M1: Hello World",
    "labels": [
        "priority:critical",
        "component:grin",
        "type:feature"
    ],
    "depends_on": [
        "13-02"
    ],
    "body": "Define the GRIN IR type hierarchy following the Modern GRIN dialect (Hruska et al., 2020).\n\n**Deliverables:**\n- `GrinExpr` tagged union:\n  - `Bind` \u2014 sequencing: `expr ; \\pat -> expr` (monadic bind)\n  - `Case` \u2014 case expression on a value\n  - `App` \u2014 function/known call application\n  - `Pure` \u2014 return a value (no side effects)\n  - `Store` \u2014 allocate a node on the heap, return pointer\n  - `Fetch` \u2014 read a node from a heap pointer\n  - `Update` \u2014 overwrite a heap node (for thunk update)\n- `GrinVal` (values):\n  - `Lit` \u2014 literal values\n  - `Var` \u2014 variable reference\n  - `ConstTagNode` \u2014 fully applied constructor node: `(CTag, [Val])`\n  - `VarTagNode` \u2014 dynamically tagged node\n  - `Unit` \u2014 unit value\n- `Tag` type: constructor tag or function tag (`C`/`F`/`P` prefix per GRIN convention)\n- `GrinDef` \u2014 top-level function definition: `(name, [param], body)`\n- `GrinProgram` \u2014 list of `GrinDef`\n- Unit tests for construction\n\n**Design notes:**\n- Follow Hruska et al. 2020 for node representation (see docs/references/grin-overview.md)\n- GRIN is an imperative-monadic language: `store`/`fetch`/`update` are explicit memory ops\n- Tags distinguish constructors (`CTag`), functions (`FTag`), and partial applications (`PTag`)\n- No higher-order functions in GRIN \u2014 all closures are defunctionalised",
    "github_issue": 40,
    "depends_on_github": [
        69
    ]
}
