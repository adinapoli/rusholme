{
    "title": "Research: Core to GRIN translation strategy",
    "epic": 6,
    "milestone": "M1: Hello World",
    "labels": [
        "priority:critical",
        "component:grin",
        "type:research"
    ],
    "depends_on": [
        "05-01",
        "06-01"
    ],
    "body": "Research and document how to translate Core IR into GRIN IR.\n\n**Key questions to answer:**\n1. How do Core lambdas become GRIN function definitions? (lambda lifting / closure conversion)\n2. How are thunks represented? (suspended function application \u2192 `store (FTag f args)`)\n3. How are partial applications represented? (PTag nodes)\n4. How do constructors map to GRIN nodes? (`Just x` \u2192 `store (CJust x)`)\n5. How does `case` translate? (Core case \u2192 GRIN case, but scrutinee may need `eval`)\n6. How is `eval` implemented? (force a thunk: fetch, case on tag, update)\n7. How are let bindings handled? (let \u2192 store thunk + bind)\n8. How are literals handled?\n\n**Deliverable:** Written document in `docs/decisions/` with the translation rules and examples.\n\n**References:**\n- Boquist, 'Code Optimisation Techniques for Lazy Functional Languages', PhD thesis, 1999 (Chapter 4)\n- Hruska et al. 2020, Section 3 (Modern GRIN)\n- GHC/GRIN project: https://github.com/grin-compiler/ghc-grin",
    "github_issue": 42,
    "depends_on_github": [
        34,
        40
    ],
    "state": "open"
}