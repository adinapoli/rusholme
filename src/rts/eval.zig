//! GRIN-model thunk evaluator for the LLVM-based runtime.
//!
//! ## Evaluation model
//!
//! Rusholme uses GRIN, not STG.  In GRIN, a suspended computation is a heap
//! node whose **tag** identifies a specific named GRIN function and whose
//! **fields** hold its arguments.  There is no opaque code pointer — the LLVM
//! backend lowers the GRIN `eval` operation to a static switch on the node tag,
//! calling the appropriate generated function by name.
//!
//! The RTS's responsibility is the bookkeeping around that dispatch:
//!
//!   - After GRIN `update`, the thunk node is overwritten with an `Ind`
//!     (indirection) pointing at the WHNF result.  Subsequent `eval` calls on
//!     the same node must follow the indirection chain to reach the value.
//!
//!   - Any node that is not an `Ind` and not a `Thunk` is already in WHNF and
//!     is returned unchanged.
//!
//! ## What this module does NOT do
//!
//! `rts_eval` does **not** force thunks itself — that is the job of the
//! LLVM-generated eval wrapper (issue #55).  Adding a generic `fn_ptr(env)`
//! dispatch here would be an STG-ism with no place in a GRIN runtime.

const std = @import("std");
const node = @import("node.zig");

// ═══════════════════════════════════════════════════════════════════════
// Thunk Evaluation
// ═══════════════════════════════════════════════════════════════════════

/// Evaluate a node to WHNF (Weak Head Normal Form).
///
/// - Follows `Ind` chains to the final value (O(n) in chain length, but
///   chains are typically short — one hop after a single `update`).
/// - Returns all other node kinds unchanged; they are already in WHNF.
///
/// Thunk *forcing* (the GRIN `eval` dispatch switch) is generated by the
/// LLVM backend and is not performed here.
///
/// Called `rts_eval` from LLVM-generated code.
pub export fn rts_eval(ptr_in: *node.Node) *node.Node {
    var ptr = ptr_in;
    while (ptr.tag == .Ind) {
        ptr = node.indTarget(ptr);
    }
    return ptr;
}

// ═══════════════════════════════════════════════════════════════════════
// Tests
// ═══════════════════════════════════════════════════════════════════════

const heap = @import("heap.zig");

test "evaluate non-thunk returns as-is" {
    heap.init();
    defer heap.deinit();

    const n = node.createInt(42);
    try std.testing.expectEqual(n, rts_eval(n));
}

test "evaluate unit returns as-is" {
    heap.init();
    defer heap.deinit();

    const n = node.createUnit();
    try std.testing.expectEqual(n, rts_eval(n));
}

test "evaluate single Ind follows to target" {
    heap.init();
    defer heap.deinit();

    const target = node.createInt(7);
    const ind = node.createInd(target);

    const result = rts_eval(ind);
    try std.testing.expectEqual(target, result);
    try std.testing.expectEqual(node.Tag.Int, result.tag);
}

test "evaluate chained Inds reaches final value" {
    heap.init();
    defer heap.deinit();

    const target = node.createInt(99);
    const ind2 = node.createInd(target);
    const ind1 = node.createInd(ind2);

    const result = rts_eval(ind1);
    try std.testing.expectEqual(target, result);
    try std.testing.expectEqual(node.Tag.Int, result.tag);
}

test "evaluate Ind pointing at Data node" {
    heap.init();
    defer heap.deinit();

    const child = node.createInt(1);
    const field_vals = [_]u64{@intFromPtr(child)};
    const data = node.createData(0x1000, &field_vals);
    const ind = node.createInd(data);

    const result = rts_eval(ind);
    try std.testing.expectEqual(data, result);
    try std.testing.expectEqual(node.Tag.Data, result.tag);
}
